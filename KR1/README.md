# Учет финансов HSE

## Описание проекта

Проект представляет собой консольное приложение для учета финансов. Основная функциональность включает:
- Управление банковскими счетами, категориями и операциями (создание, редактирование, удаление).
- Динамическое изменение счета в зависимости от операций (добавление операции пересчитывает счет пользователя,
а также счет пересчитываетсся при любом значимом изменении категории или операции, например изменение типа категории
с расхода на доход или привязки операции к другому пользователю).
- Работа с базой данных (файл базы данных `FinanceDatabase.db` находится вместе с исполняемым файлом).
- Консольный интерфейс с возможностью навигации стрелочками.

### Реализованные функциональные требования
Все обязательные функциональные требования реализованы. Поскольку задание позволяет опускать ненужную опциональную функциональность
, в проекте реализуется только обязательная функциональность.

---

## Принципы SOLID и GRASP

### SOLID

1. **Single Responsibility Principle (Принцип единственной ответственности)**:
   - Каждый класс отвечает за одну задачу. 

2. **Open/Closed Principle (Принцип открытости/закрытости)**:
   - Программные сущности (классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для модификации.
   Например, добавление новых команд в консольный интерфейс не требует изменения существующего кода.
   - Также расширение функционала производится путем наследования класса, а не изменение уже существующего кода.

3. **Liskov Substitution Principle (Принцип подстановки Барбары Лисков)**:
   - Все наследники умеют делать все то же, что и родители. Например, наследники класса `Menu` реализуют все его методы и могут быть использованы вместо него.

4. **Interface Segregation Principle (Принцип разделения интерфейса)**:
   - Используемые интерфейсы отвечают только за одну функцию. Например, интерфейс `ICommand` содержит только один метод.
   Интерфейс `IFinanceDatabase` содержит только методы для работы с базой данных, его разделение на несколько интерфейсов нецелесообразно.

5. **Dependency Inversion Principle (Принцип инверсии зависимостей)**:
   - Модули связаны друг с другом через абстракции. Например, модуль Console Interface взаимодействует с Database исключительно через `IFinanceDatabase` и 
   не зависит от реализации (из-за чего был легко заменен Proxy объектом).

### GRASP

**High Cohesion и Low Coupling (Высокая связность)**

Классы в рамках одного модуля сильно связаны (например, модуля Console Interface, они все тесно взаимодействуют с друг другом), но слабо связаны с классами других модулей
(например, классы Console Interface связываются с модулем Database исключительно через интерфейс `IFinanceDatabase`).

---

## Реализованные паттерны

1. Команда + декоратор:
   - Команда (`ICommand`) используется для реализации команд в консольном интерфейсе. Каждый пункт меню представляет собой `MenuItem`, содержащий
   название пункта меню и соответствующую команду. При выборе пункта меню вызывается соответствующая команда.
   - Декоратор используется для добавления дополнительной функциональности к командам. Например, декоратор `FinalCommand`
   очищает консоль перед выполнением команды, которую декорирует, а затем после выполнения команды ожидает ввода пользователя
   для перехода обратно к главному меню. Этот декоратор позволяют пользователю увидеть результат выполнения команды и затем двинуться дальше.

2. Фасад
   - Класс `DataGetterFacade` является "оберткой" над средствами системы типо Console.ReadLine, Console.WriteLine и т.д, а также моими классами,
   например классом `Menu`, который позволяет выбрать пользователю что-то из списка. Таким образом, этот класс предоставляет простой (со внешней стороны)
   способ получить нужные данные от пользователя.

3. Прокси + Фабрика
   - Класс `FinanceStorageProxy` является прокси-объектом для класса `FinanceDatabase`. Запросы типа GET (GetAccounts, GetCategories, GetOperations) выполняются без обращения к базе данных, потому что
   прокси-объект в момент своего создания подтягивает все данные из базы данных, а затем когда выполняется какая-либо либо операция другого типа (добавление, удаление, изменение), то прокси-объект
   отправляет запрос к базе данных и делает аналогичную операцию у себя, тем самым поддерживая актуальность данных. Также прокси-объект отсеивает заведомо ложные запросы.
   - Класс `FinanceStorageProxy`, по сути своей, также является и фабрикой. Только он отвественный за создание новых доменных объектов, нигде в другом месте создание не происходит.
   Да, можно сказать, что это не фабрика в классическом понимании, потому что она не возвращает объект "наружу", но в данном случае это и не требуется. Все доменные сущности существуют
   только вместе, по отдельности в них смысла нет. Также нет смысла в создании отдельного класса фабрики, потому что вся логика валидации данных находится в Proxy объекте и фабрика об этом никак не может знать
   (например, создание операции требует проверить существование счета и категории, а фабрика отдельно от Proxy этого сделать не может). А создавать фабрику, которая просто будет вызывать new, не имеет смысла,
   поэтому считаю это объединение полностью оправданным.

4. Шаблонный метод
   - Класс `DataExporterTemplate` является шаблонным классом, у которого определены методы `SerializeData` и `SaveToFile`.
   Наследники `CsvExporter` и `JsonExporter` переопределяют метод `SerializeData` для сериализации данных в соответствующий формат.

**Итого:** Суммарно 6 паттернов, как и требовалось.

---

## Инструкция по запуску

### Требования
- .NET 9 или выше.
- Также должны быть установлены следующие NuGet пакеты:
    - ConsoleTables версии 2.6.2
    - Microsoft.Data.Sqlite версии 9.0.3
    - Microsoft.Extensions.DependencyInjection версии 9.0.3
    - CsvHelper версии 33.0.1

 Все пакеты можно быстро установить, выполнив следующую команду в папке с `.sln`:
 ```bash
 dotnet restore
 ```

### Запуск
Чтобы запустить приложение, выполните следующую команду в папке с `KR1` (папка проекта, где
есть файл `KR1.csproj`, при запуске программы таким способом, все создаваемые файлы будут созданы в этой
же папке `KR1`):
```bash
dotnet run
```
Запустить также можно по средствам Visual Studio, нажав на кнопку "Запуск".